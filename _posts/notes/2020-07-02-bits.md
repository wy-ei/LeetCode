---
title: 位运算
layout: post
category: 总结
published: false
---


```cpp
// 最低位 1 的 mask
y = x & ~(x − 1)
```

翻转比特位

<div class="toc" data-level="1"></div>


# 奇偶校验

如果一个数二进制表示中 1 的个数为偶数则返回 0，如果为奇数则返回 1。

可以先统计出 1 的位数，然后判断奇偶。但是这里采用另一种思路。

两个数异或，如果两者对应的位相同，该位异或后为 0，反之为 1。如果把一个数的前半部分和后半部分异或，就可以一次性消除成对的 1。余下的数中 1 的数量的奇偶性和原来的数是一样的。所以，如此反复异或，最终可以把奇偶信息压缩到一位上。

```c++
short parity(unsigned int n){
    n ^= n >> 32;
    n ^= n >> 16;
    n ^= n >> 8;
    n ^= n >> 4;
    n ^= n >> 2;
    n ^= n >> 1;
    return n & 1;
}
```


## 交换 bit (异或)

给定两个索引 i 和 j，交换一个数中 i 和 j 两位。

直接的思路如下：

先比较 i 和 j 两位的值。如果两者相同，那就不用交换。否则，将这两位的比特位翻转。

翻转比特的直观想法是，先取出对应 bit 然后根据其值将其设为 1 或 0。设置为 1 的方法是 `n |= 1 << i`，设置为 0 的方法是 `n &= ~(1<<i)`。这需要一个条件语句，比较麻烦。

最简单的方法是使用异或操作，某个位上与 1 异或，就能实现翻转。

```cpp
int swap_bits(int n, int i, int j){
    if( ((n >> i) & 1) != ((n >> j) & 1) ){
        n ^= 1L << i | 1L << j;
    }
    return n;
}
```


