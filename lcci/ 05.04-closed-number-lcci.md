##  05.04. 下一个数

- 难度：Medium
- 题目链接：[https://leetcode-cn.com/problems/closed-number-lcci/](https://leetcode-cn.com/problems/closed-number-lcci/)


## 题目描述

来源于 [https://leetcode-cn.com/](https://leetcode-cn.com/)

<p>下一个数。给定一个正整数，找出与其二进制表达式中1的个数相同且大小最接近的那两个数（一个略大，一个略小）。</p>

<p> <strong>示例1:</strong></p>

<pre>
<strong> 输入</strong>：num = 2（或者0b10）
<strong> 输出</strong>：[4, 1] 或者（[0b100, 0b1]）
</pre>

<p> <strong>示例2:</strong></p>

<pre>
<strong> 输入</strong>：num = 1
<strong> 输出</strong>：[2, -1]
</pre>

<p> <strong>提示:</strong></p>

<ol>
<li><code>num</code>的范围在[1, 2147483647]之间；</li>
<li>如果找不到前一个或者后一个满足条件的正数，那么输出 -1。</li>
</ol>


## 解法：

找下一个数很简单，从低位到高位寻找第一个 `01`，然后把 `01` 改为 `10`，然后把后面的位做 reverse。举个例子，假如寻找到的 `01` 左边的各位是 `11000`，需要 reverse 一下，变成 `00011`。

找前一个数，需要从低位到高位寻找第一个 `10`，将其修改为 `01`，然后把后面的位做 reverse。

上面的操作，和寻找下一个排列组合非常相似。设 `num = 1,837,591,841`，把 num 的 32 位从高位到低位放到数组中，有

```
110 1101 1000 0111 0110 1101 0010 0001‬
```

下一个较大的数的各个位，不就是把这个数组的下一个排列组合吗？

而前一个较小的数，不就是这个数组的前一个排列组合吗？但是寻找前一个排列组合，只需要修改一下比较函数即可。


```c++
class Solution {
public:
    vector<int> findClosedNumbers(int num) {
        return {next(num) , prev(num)};
    }

    int next(int num){
        vector<char> bits;
        for(int i=31;i>=0;i--){
            bits.push_back(bit(num, i));
        }

        if(next_permutation(bits.begin(), bits.end())){
            int n = 0;
            for(int i=0;i<bits.size();i++){
                if(bits[i] == 1){
                    n = set_bit(n, 31-i, 1);
                }
            }
            return n;
        }else{
            return -1;
        }
    }

    int prev(int num){
        vector<char> bits;
        for(int i=31;i>=0;i--){
            bits.push_back(bit(num, i));
        }
        auto comp = [](int a, int b){
            return a > b;
        };
        if(next_permutation(bits.begin(), bits.end(), comp)){
            int n = 0;
            for(int i=0;i<bits.size();i++){
                if(bits[i] == 1){
                    n = set_bit(n, 31-i, 1);
                }
            }
            return n;
        }else{
            return -1;
        }
    }

    int bit(int num, int i){
        if(num & (1 << i)){
            return 1;
        }else{
            return 0;
        }
    }

    int set_bit(int num, int i, int val){
        if(val){
            return num | (1 << i);
        }else{
            return num & ~(1 << i);
        }
    }
};
```